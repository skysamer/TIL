# 브라우저 주소창에 URL을 입력하면 발생하는 일
</br>
</br>


## 💡 브라우저가 주소창에 입력된 URL을 해석
주소를 입력하면, 브라우저가 URL을 해독해서 원격지에서 조회할 웹서버, 파일명, 포트번호를 확인하고 HTTP 메시지 포맷에 맞게 리퀘스트 메시지를 준비한다.

-----
</br>

## 💡 HTTP 메시지를 작성
해석한 정보를 바탕으로 HTTP 메시지 포맷에 맞는 상태라인, 바디 헤더를 가지고 있는 리퀘스트 메시지를 작성

-----
</br>

## 💡 브라우저가 DNS 요청을 OS에 의뢰하고 실행
DNS는 **도메인 주소와 IP주소를 대응시키기 위한 서버**다. 이때 도메인을 .으로 분리하여 계층화된 도메인 정보를 DNS 서버에 정보를 분산시켜 다수의 DNS 서버에 등록한다.
그리고 DNS 조회 요청이 오면 URL에 해당하는 부분을 따라가며, 다수의 DNS 서버가 연대하여 IP 정보를 찾아내는 구조다.

DNS 요청의 프로토콜은 UDP이고, DNS 서버의 IP주소는 컴퓨터의 TCP/IP 설정항목중 하나이기 때문에 OS가 이미 알고 있다. 
액세스 대상의 웹 서버가 DNS에 포함되어 있으면 IP주소를 포함한 응답이 오고, 응답은 OS의 **DNS 리졸버**가 내용을 해석한 후, 
IP주소를 추출하여 메모리에 저장하고 브라우저의 프로세스가 접근 할 수 있게 한다.

브라우저는 직접 네트워크 요청을 할 수 없기 때문에, DNS 요청을 포함한 모든 네트워크 요청은 OS에 의뢰한다.

-----
</br>

## 💡 브라우저가 OS의 프로토콜 스택에 메시지 송신을 의뢰하고, 소켓을 작성
TCP/IP에 사용되는 프로토콜 스택의 실제 구현체는 OS에 존재한다.

소켓은 두 단말의 통신동작을 제어하기 위한 제어정보의 총체이다. 통신 제어 정보를 기록하는 메모리 영역을 가리키는 말이기도 하다.
클라이언트에서 DNS조회로 IP주소를 알아내면 지정된 포트 번호는 서버측 컴퓨터의 프로세스를 특정하기 때문에, 서버측 컴퓨터의 어떤 소켓과 통신할지 지정할 수 있다.

통신 종단점의 두 소켓은 파이프로 읽기 쓰기 동작을 거듭하며 데이터를 주고받는다. OS에서는 소켓이 만들어지면 메모리 공간을 확보하고 파일 디스크립터를 통해 소켓을 식별한다.

-----
</br>

## 💡 TCP 프로토콜 스택은 Three-Way HandShake를 통해 서버와의 연결을 구축한다.
TCP 프로토콜 스택은 Three-Way HandShake를 통해 SYN과 ACK 비트를 주고받으며 각 단말이 통신가능한 상태인지 확인한다. 과정은 다음과 같다.
1) 처음에 송신처에서 접속 요청 프로세스가 SYN 비트를 1로 만들어 연결 메시지를 전송한다.
2) TCP 헤더를 받은 서버는 포트번호에 해당하는 소켓을 찾고 필요한 정보를 기록해서 접속 동작이 진행된다. 서버가 요청을 수락하면 수신처도 SYN, ACK 비트를 1로 만들어 재전송한다.
3) 서버에서 돌아오는 헤더를 받은 프로세스에서는 SYN이 1이면 접속 성공으로 소켓의 서버 IP주소나 포트번호등과 함께 소켓에 접속완료를 나타내는 제어 정보를 입력한다.
4) 클라이언트는 패킷을 받았다는 것을 알리기 위해 ACK비트를 1로만든 TCP 헤더를 반송한다.

-----
</br>

## 💡 TCP 프로토콜 스택에서 패킷을 만들고 TCP 헤더를 붙인다.
여기서부터 OSI 4계층, 전송 계층의 시작이다.

핸드셰이크를 통해 접속이 성립되었으면, 서버로 보내야하는 HTTP 메시지를 TCP로 보낼 수 있는 최대치에 맞춰 메시지를 자르고 
자른 데이터들마다 TCP 헤더를 붙여 제어 정보를 작성한다.
첫번째로 데이터를 조각낸 패킷을 만든다.

TCP 헤더의 주요한 정보들로는 송수신처의 포트 번호, 데이터 오프셋(데이터의 시작지점), 
ACK 번호, 6비트짜리 컨트롤 비트(URG, ACK, FIN, SYN, PSH, RST)가 있다.

-----
</br>

## 💡 IP 프로토콜 스택이 패킷을 더 잘게 나누고 원격지의 MAC주소를 기반으로한 MAC헤더를 붙인다.
TCP에서 만든 패킷의 기본적인 단위들을 회선과 네트워크 상황에 맞게 MTU를 기반으로 더 잘게 나누고,
이렇게 나눠진 패킷에 IP헤더를 붙인다. 그런데 단말이 소통하려면 IP주소 뿐만아니라, LAN카드의 고유한 MAC주소가 필요하다.

ARP는 IP주소를 기반으로 MAC주소를 알아내는 역할을 한다. ARP는 먼저 같은 네트워크 내부의 브로드캐스트로 요청을 보내서 원격지 서버가 네트워크 내부에 있으면 해당 단말의 MAC주소를,
외부에 있으면 네트워크 라우터의 MAC주소를 가져온다. 알아낸 주소를 토대로 MAC헤더를 패킷에 만들어 붙인다.

-----
</br>

## 💡 LAN 어댑터를 통해 바이너리 데이터를 전기신호로 변환한다.
송신측에서 패킷 읽을 타이밍을 잡을때 쓰는 프리앰블 비트, 패킷의 개시 위치가 어디부터인지 알게해주는 비트, 
패킷 오류 검출을 위한 FCS 등의 데이터를 추가하여이진 데이터를 전기신호로 바꾼다.

LAN카드가 없는 다음의 경우에도 바이너리를 전기신호로 변환할 수 있다.

1) wifi 공유기 : 공유기에 LAN 어댑터가 있으므로, 이를 통해서 전기신호를 보낸다.
2) 스마트폰 : 가장 가까운 기지국으로 전기 신호를 보낸다.

-----
</br>

## 💡 원격지의 MAC 주소로 전기 신호를 송출한다.
전기신호를 LAN 케이블을 통해 송출한다. 데이터가 집밖으로 나가는 순간이다. 이때 원격지가 대역폭이 다른 외부 네트워크라면
패킷은 네트워크의 라우터로, 내부 네트워크라면 해당 원격지로 전송한다.

전기 신호가 같은 내부 네트워크를 돌면서 원격지 서버를 찾아갈때, 스위치라는 2계층 장비를 만날 수 있다.
스위치 하나에 여러개의 단말이 붙어있고, 이 스위치들을 모아 네트워크를 만들 수 있다.
스위치는 FSC를 대조하여 패킷의 오류 유무를 검사하거나 맥 주소 테이블을 통해 해당 스위치에 붙은 단말이 패킷의 목적지인지 검사한다.

-----
</br>

## 💡 패킷의 목적지가 외부 네트워크면 네트워크의 라우터에 패킷이 도착한다.
라우터에 도착한 패킷은 연결되어 있는 포트를 통해 다른 네트워크에 존재하는 원격지 MAC 주소를 알아내기 위해 ARP를 원격지에 요청하고,
라우팅 테이블을 뒤져서 패킷을 중개하기 위한 경로를 탐색하고 전기 신호를 송신한다.

라우팅 테이블은 수신처의 정보와 수신처까지의 거리 등의 정보를 기록하는 표다. 라우터는 이 항목에 등록되어있는 IP주소와
수신한 패킷의 수신처 IP주소를 조사하여 패킷을 어디로 보낼지 최적의 경로를 찾아준다.

-----
</br>

## 💡 액세스 회선, 인터넷 접속용 라우터를 통과하여 인터넷의 내부로 중개된다.
라우터를 나간 패킷은 인터넷의 액세스 회선을 통과하며 장거리 통신에 적합한 형태로 변형되고, 추가적인 제어 정보를 붙여 인터넷에 내부로 중개된다.
이 단계에서 전기신호는 건물의 옥내 배선을 지나 전신주의 전화 케이블로 들어간다. 
전신주를 타고 이 전기신호들은 통신사의 전화국으로 들어가고 거기서 또 인터넷 접속용 라우터를 거쳐 인터넷의 내부로 중계되기 시작한다.

-----
</br>

## 💡 인터넷 내부에서의 패킷 흐름
인터넷의 실체는 다수의 프로바이더가 네트워크를 서로 접속한 것이다. 쉽게는 여러 통신사들의 무수한 라우터들이 인터넷을 이루고 있다.
여러 프로바이더의 여러 라우터 장비를 거치면서 최종적으로 목적지 서버가 포함된 네트워크의 라우터를 거쳐 해당 목적지 웹서버의 단말로 패킷이 전송된다.

-----
</br>

## 💡 웹 서버로 전기 신호가 도착한 이후의 동작
전기신호를 받은 웹 서버의 LAN 어댑터가 전기 신호를 이진 데이터로 변환한다. 
패킷의 MAC 주소를 비교하고 FSC로 패킷의 손상여부를 판단하여 OS의 프로토콜 스택으로 전송한다.

프로토콜 스택의 IP 담당 부분에서 IP 헤더를 바탕으로 잘려진 패킷을 다시 리어셈블링하고 IP 주소가 제대로 됐는지 검증하고
TCP 담당부분으로 전송한다. TCP 담당 부분은 TCP 헤더를 토대로 잘려진 패킷들을 완성된 데이터로 만들고 클라이언트에 수신 확인용 ACK 번호를 반송한다.

완성된 데이터를 제어 정보와 포트번호를 토대로 TCP HandShake할때 만들어 놓은 적합한 소켓을 찾는다. 완성된 데이터를 소켓에 기록해 애플리케이션의 프로세스에 건네준다.

이 과정이 네트워크 계층을 올라가면서 전기 신호를 바탕으로 조각난 패킷과 헤더 정보를 바탕으로 클라이언트에서 전송한 데이터를 재조립하는 디캡슐레이션 과정이다.

-----
</br>

## 💡 서버 애플리케이션은 완성된 요청 메시지를 받고 응답 메시지를 작성한다.
서버 애플리케이션이 http 요청메시지를 받으면 요청 URI를 실제 서버의 파일 시스템의 URI로 바꿔 해당되는 html자원을 찾아 바디에 넣은 후 헤더와 함께 응답메시지를 작성한다.
서버도 똑같이 프로토클 스택을 다시 내려가며 패킷 처리를 하고 인터넷과 라우터들을 거쳐 응답 메시지를 클라이언트에 전송한다.

-----
</br>

## 💡 응답 메시지를 받은 클라이언트 브라우저의 동작
클라이언트 브라우저는 http 메시지의 content-type 헤더를 보고 응답데이터가 html임을 알아낸다. 이를 바탕으로 브라우저가 화면 표시 동작을 실행한다.
화면 표시는 브라우저 프로세스의 렌더리스레드가 담당한다.

브라우저는 html을 파싱하여 Critical Rendering Path를 거쳐 해석된 html을 화면에 띄우고 script나 link 태그를 만나면 렌더링을 중단하고 똑같은 과정을 거쳐
js, css자원을 서버에 요청한다.

-----
</br>

## 💡 요청이 종료되면 4-Way-HandShake를 통해 접속을 끊고 소켓을 말소한다
데이터 송수신 과정이 끝나면 접속을 끊기 위해 4-Way-HandShake 과정을 실행한다.
1) 요청-응답이 완료되면 서버는 TCP의 FIN 비트에 1을 설정에 연결이 끝났음을 클라이언트에 알린다.
2) 클라이언트는 이때 서버에서 보낸 데이터를 모두 수신 완료했다는 사실을 어플리케이션에 알리고 송수신 동작을 정리한다.
3) 클라이언트 측의 프로토콜 스택이 FIN 1 TCP헤더를 만들어 서버에 송신한 후 서버에서 ACK가 돌아오면 서버의 접속이 종료되고 소켓을 말소한다

keep-alive timeout 설정이 지나고 난 후, 서버-클라이언트 간 접속이 끊어지고 소켓이 만료된다.

-----
</br>
