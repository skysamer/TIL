## 1. URL 입력의 원리
URL은 http:// 로 시작하는것 뿐만 아니라 file:, mailto: 등 여러가지가 존재한다. 이러한 이유는 브라우저는 파일 업로드 기능, 
메일 기능 등 다양한 기능을 겸비한 복합적인 클라이언트 소프트웨어이기 때문이다.

URL의 맨 앞에 있는 문자열, 즉 http:, ftp:, file:, mailto: 라는 부분에서 액세스하는 방법을 나타낸다. 액세스 대상이 웹 서버라면 HTTP라는 프로토콜을 사용하여 액세스하는 방식이다.
즉, 여기에는 액세스할 때의 프로토콜 종류가 쓰여있다고 보면 된다.

- FTP: 파일을 업로드하거나 다운로드할 때 사용하는 프로토콜이다.
- 포트 번호: 엑세스 대상 서버 애플리케이션을 지정하여 사용하는 번호
- 프로토콜: 통신 동작의 규칙을 정한 것
-----
</br>

## 2. 브라우저의 URL 해독
브라우저가 처음 하는 일은 웹 서버에 보내느 리퀘스트 메시지를 작성하기 위해 URL을 해독하는 것이다. URL을 해독할때는 다음과 같이 요소를 따로따로 분해하여 해독한다.
  - **http:// 프로토콜/웹서버/디렉토리/파일**

이 방식은 http:로 시작하는 URL의 대표적인 예다. 이것과는 조금 달리 /로 끝나는 경우가 있는데
이는 파일명을 쓰지 않고 생략하는 경우를 말한다. 이러한 경우에는 생략할때를 대비하여 파일명을 미리 서버측에 설정해야 한다.
 - **http:// www.lab.cyber.co.kr/디렉토리/**

디렉토리명과 끝의 '/'까지 생략한 경우도 있는데 이러한 경우도 루트 디렉토리의 아래에 있는 미리 설정된 파일명의 파일에 액세스하는 경우 허용되고 있다.
 - **http:// www.lab.cyber.co.kr/**
 
-----
</br>

## 3. HTTP의 기본 개념
URL을 해독한 이후에 HTTP 프로토콜을 사용하여 웹 서버와 액세스한다. 
HTTP 프로토콜은 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.

먼저 클라이언트에서 서버에 리퀘스트 메시지를 보낸다. 리퀘스트 메시지는 '무엇을', '어떻게 해서' 하겠다는 양식으로 작성되어 있다.
이때 '무엇을'에 해당하는 부분을 **URI**라고 한다. 페이지 데이터를 저장한 파일의 이름이나 CGI프로그램의 파일명을 URI로 쓴다.
즉, 액세스 대상을 통칭하는 말이 URI다.

'어떻게 해서'에 해당하는 것은 **메소드**로, 메소드에 의해 웹 서버에 어떤 동작을 하고 싶은지를 전달한다. 
메소드 종류에는 GET, POST 등이 있다.

응답 메시지의 맨 앞부분에는 실행 결과가 정상 종료되었는지 또는 이상이 발생했는지를 나타내는 **스테이터스 코드**가 있다.
'404 not fount'와 같은 메시지가 스테이터스 코드다.

메소드 중에 가장 자주 사용하는 것은 'GET 메소드'다. 웹 서버에 액세스하여 페이지의 데이터를 읽을 때 사용한다.

다음으로 자주 사용하는 것은 'POST'라는 메소드로, 폼에 데이터를 입력해서 웹 서버에 송신하는 경우에 사용한다.
POST 메소드를 사용한 경우 URI에는 웹 서버 기계에서 동작하는 애플리케이션 프로그램의 파일명을 쓴다.
그리고 리퀘스트 메시지 안에는 CGI 프로그램이나 스크립트에 건네주는 데이터도 쓴다.

- CGI 프로그램: 웹 서버 소프트웨어에서 프로그램을 호출할 때의 규칙을 정한 것(CGI)

## 4. HTTP 리퀘스트 메시지
URL을 해독하고 웹 서버와 파일명을 판단하면 브라우저는 HTTP 리퀘스트 메시지를 만든다. 
리퀘스트 메시지는 포맷이 결정되어 있으므로 브라우저는 이 포맷에 맞게 리퀘스트 메시지를 만든다.

먼저 리퀘스트 메시지의 첫 번째 행에 있는 **리퀘스트 라인**을 작성한다. 이 행에는 메소드가 작성되어 있어 웹 서버에 데이터를 어떻게 할 것인지를 보낸다.
메소드는 여러 종류가 있으므로 어떤 메소드를 사용할 지 판단해야 한다. 보통 URL 입력 상자에 URL을 입력하면 해당 페이지를 표시하므로 GET 메소드를 사용한다.
메소드를 썼으면 URI를 쓴다. 파일이나 프로그램의 경로명을 쓰는 것이 보통이다. 경로명은 URL에 포함되어 있으므로 복사해서 붙여넣는다.

두 번째 행부터는 **메시지 헤더**가 있다. 부가적인 자세한 정보를 써 두는 것이 메시지 헤더의 역할이다.
날짜, 언어 데이터 종류 등이 포함되어 있다.

메시지 헤더를 쓰면 그 뒤에 아무 것도 쓰지 않은 하나의 공백 행을 넣고 그 뒤에 송신할 데이터를 쓴다.
이 부분을 **메시지 본문**이라 하며, 이것이 메시지의 실제 내용이 된다.
단 메소드가 GET인 경우 메소드와 URI만으로 웹 서버가 무엇을 할지 알 수 있으므로 메시지 본문이 존재하지 않는다.

이 메시지를 보내면 웹 서버에서 응답 메시지가 되돌아온다.
응답의 경우 리퀘스트의 실행 결과를 나타내는 스테이터스 코드와 응답 문구를 첫 번째 행에 써야한다.

응답 메시지가 되돌아오면, 그때부터 데이터를 추출한 후 화면에 표시하여 웹 페이지를 눈으로 볼 수 있다.
영상 등을 포함한 경우에는 문장 안에 영상 파일을 나타내는 태그라는 제어 정보를 포함시킨다.

리퀘스트 메시지에 쓰는 URI는 한 개만으로 결정되어 있으므로 파일을 한번에 한 개씩만 읽을 수 있기 때문에 파일을 따로따로 읽어야한다.
웹 서버는 이때 단순히 한 개의 리퀘스트에 대해 한 개의 응답만 돌려보낼 뿐이다.

- 복수의 파일을 읽을 때는 웹 서버에 별도의 리퀘스트 메시지를 보낸다.

-----
</br>


## 5. IP 주소의 기본
브라우저는 HTTP 메시지를 네트워크에 송출하는 기능이 없으므로 OS에 의뢰하여 송신하게 된다. 
이때 서버의 도메인명이나 IP 주소를 조사해야한다.
그러므로 HTTP 메시지를 만드는 동작의 다음은 도메인명에서 IP 주소를 조사하는 동작이 된다.

먼저 TCP/IP의 개념부터 알아야한다.  TCP/IP는 서브넷이라는 작은 네트워크를 라우터로 접속하여 전체 네트워크로 만들어진다.
여기서 서브넷은 허브에 몇 대의 pc가 접속된 것으로 봐도 된다. 이것을 라우터에서 연결하면 전체 네트워크가 완성된다.

여기에 네트워크 주소를 할당하게 된다. 네트워크 주소를 둘로 나눠서 하나는 서브넷, 다른 하나는 컴퓨터에 할당하게 된다.
여기서 전자를 **네트워크 번호**라 하고 후자를 **호스트 번호**라 하며 이 두 주소를 합쳐서 **IP 주소**라고 한다.
이 IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다.
- IP 주소: 네트워크 번호 + 호스트 번호

실제 IP 주소는 32비트의 디지털 데이터로, 이것을 8비트씩 점으로 구분하여 10진수로 표기한다.
그러나 IP 주소만으로는 네트워크 번호와 호스트 번호를 구분할 수 없는데 이 정보를 나타내는 것이 **넷마스크**라고 한다.
넷마스크 또한 32비트 부분의 디지털 데이터이며, 1인 부분은 네트워크 번호를 나타내고 0인 부분은 호스트 번호를 나타낸다.
- 255.255.255.0 -> 11111111.11111111.11111111.00000000

호스트 번호 부분의 비트 값이 모두 0 또는 1인 경우는 특별한 경우를 나타낸다.
- 모두 0: 서브넷 자체를 의미
- 모두 1: 서브넷에 있는 기기 전체에 패킷을 보내는 '브로드캐스트'를 의미

일반적으로 기억을 위해 URL 안에는 IP 주소가 아닌 서버의 이름을 쓰는 것이 권장된다.
반대로 네트워크의 속도와 효율성을 위해 이름으로 서버를 지정하는 것이 아닌 IP 주소를 지정하여 통신하게 된다.

-----
</br>

## 6. Socket 라이브러리
IP 주소는 가장 가까운 DNS 서버에 의뢰하여 조사한다.
DNS 클라이언트에 해당하는 것을 **DNS 리졸버** 또는 단순히 **리졸버**라고 부른다.
그리고 DNS의 원리를 이용하여 IP 주소를 조사하는 것을 **네임 리졸루션** 이라고 한다. 이 리졸루션을 실행하는 것이 리졸버다.

리졸버의 실체는 **Socket 라이브러리**에 들어있는 부품화한 프로그램으로, 
소켓 라이브러리는 OS에 포함되어 있는 네트워크의 기능을 애플리케이션에서 호출하기 위한 부품을 모아놓은 것이다.

리졸버의 프로그램명과 웹 서버의 이름을 쓰기만 하면 리졸버를 호출할 수 있다.
이렇게 리졸버를 호출하면 리졸버가 DNS 서버에 조회 메시지를 보내고, DNS 서버에서 응답 메시지가 돌아오는데,
여기에 IP 주소가 포함되어 있다.

리졸버를 호출하게 되면 제어가 리졸버의 내부로 넘어가게 된다.
'제어가 넘어간다' 라는 표현은 별도의 프로그램을 호출하여 호출처의 프로그램이 쉬고 있는 상태가 되며, 호출한 대상 프로그램이 움직이기 시작하는 것으로 해석할 수 있다.
제어가 넘어가면 DNS 서버에 문의하기 위한 메시지를 만든다.
메시지 송신 동작은 리졸버가 스스로 수행하는 것이 아닌 **프로토콜 스택**을 호출하여 실행을 의뢰한다.
- 프로토콜 스택: OS 내부에 내장된 네트워크 제어용 소프트웨어

액세스 대상의 웹 서버가 DNS 서버에 등록되어 있으면 답을 응답 메시지에 써서 클라이언트에 반송한다.
메시지는 네트워크를 통해 클라이언트측에 도착하고, 프로토콜 스택을 경유하여 리졸버에 건네져서 리졸버가 내용을 해독한 후 IP 주소를 추출하여 애플리케이션에 건네주게 된다.
이로써 리졸버의 동작이 끝나고 제어가 브라우저에 돌아온다.

-----
</br>

## 7. DNS 서버
DNS 서버의 기본동작은 클라이언트에서 조회 메시지를 받고 조회의 내용에 응답하는 형태로 정보를 회답하는 일이다.
조회 메시지에는 세 가지 정보가 포함되어 있다.
- 이름
- 클래스: 클래스는 항상 인터넷을 나타내는 'IN'이라는 값이된다.
- 타입: 타입이 A인 경우 IP 주소가 지원되고 MX이면 이름에 메일 배송 목적지가 지원된다는 의미다.

이름과 타입에 따라 조사하는 정보를 지정하고, 그것에 따라 해당하는 것을 찾아 클라이언트에 답하는 것이 DNS 서버의 기본 동작이다.

-----
</br>

## 8. 도메인의 계층
DNS 서버는 모든 IP 주소 정보를 한 대의 DNS 서버에 등록하는 것은 불가능하므로, 정보를 분산시켜 다수의 DNS 서버에 등록하고, 다수의 DNS 서버가 연대하여
정보가 등록되어 있는 곳을 찾아내는 구조로 구성되어 있다.

DNS 서버에 등록한 정보에는 모든 **도메인명**이라는 계층적 구조를 가진 이름이 붙여져 있다.
 - 도메인명: www.lab.cyber.co.kr
여기서 점으로 구분되어 있는 각각을 **도메인**이라고 한다. 오른쪽에 위치한 것이 상위의 계층을 나타낸다.
이렇게 계층화된 도메인의 정보를 서버에 등록하는데 이때 하나의 도메인을 일괄적으로 취급한다.
**즉 한 대의 DNS 서버에 도메인 한 대를 등록하게 된다.**

인터넷에는 수만 대의 DNS 서버가 존재하므로 정보를 찾기 위해 하나하나 찾아다닐수 없다.
그래서 먼저 하위의 도메인을 담당하는 DNS 서버의 IP 주소를 그 상위의 DNS 서버에 등록한다.
그리고 상위의 DNS 서버를 또 그 상위의 DNS 서버에 등록하는 식으로 한다.

도메인에서 com이나 kr과 같은 도메인을 **최상위 도메인**이라고 한다. 그리고 이 상위에는 **루트 도메인**이라는 도메인이 존재한다.
위의 작업을 모두 거친 후 마지막으로 루트 도메인의 DNS 서버를 인터넷에 존재하는 DNS 서버에 모두 등록하면 등록을 마치게 된다.

-----
</br>

## 9. 캐시 기능
현실의 인터넷에서는 한 대의 DNS 서버에 복수 도메인의 정보를 등록할 수 있으므로
각 도메인에 한 대씩 DNS 서버가 존재한다고 단정할 수 없다.
또한 현실에서는 상위와 하위의 도메인을 같은 DNS 서버에 등록하는 경우도 있다.

DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있는데, 조회한 이름에 해당하는 정보가 캐시에 있으면 그 정보를 회답한다.
단, 캐시에 정보를 저장한 후 등록 정보가 변경되는 경우도 있으므로 캐시 안에 있는 정보는 올바르다고 단언할 수 없다.
 - 캐시: 한 번 사용한 데이터를 고속의 기억 장치에 저장하여 두 번째 이후의 이용을 고속화하는 기술

-----
</br>

## 10. 데이터 송수신 동작
IP 주소를 조사하면 액세스 대상 웹 서버에 HTTP 메시지(디지털 데이터)를 송신하도록 OS 내부에 있는 프로토콜 스택에 의뢰한다.
이때 Socket 라이브러리 프로그램 부품을 결정된 순번대로 호출한다.

데이터를 송수신하는 컴퓨터 사이에 데이터의 통로 같은 것이 있고, 이것을 통해 데이터가 흐르면서 상대에게 도착한다.
이 데이터 통로는 항상 존재하지 않고 송수신 동작을 하기 전에 이 통로 연결작업이 필요하다.
요점은 통로 양 끝에 있는 데이터의 출입구다. 이 출입구를 **소켓**이라고 한다.
실제로는 서버측에서 먼저 소켓을 만들고 클라이언트 측이 만들기를 기다린다.

송수신동작이 끝나고 나면 연결했던 통로가 분리된다.
데이터 송수신 동작을 요약하면 4단계로 할 수 있다.

1) 소켓을 만든다
2) 서버측의 소켓에 통로를 연결한다.
3) 데이터를 송수신한다.
4) 파이프를 분리하고 소켓을 말소한다.

위의 네 가지 동작을 실행하는 것은 OS 내부의 프로토콜 스택이다.
애플리케이션은 프로토콜 스택에 의뢰하여 데이터를 송수신하게 된다.

-----
</br>

## 11. 소켓의 작성
클라이언트의 소켓을 만드는 것은 소켓 라이브러리의 Socket이라는 프로그램을 호출하면 끝난다.
호출 후의 동작은 socket 내부에 제어가 넘어가서 소켓을 만드는 동작을 실행하고 끝나면 애플리케이션에 제어가 돌아온다.

소켓이 생기면 **디스크립터**라는 것이 돌아오고 애플리케이션은 이것을 받아서 메모리에 기록한다.
디스크립터는 소켓을 식별하기 위해 사용하는 것으로 소켓의 고유번호로 생각하면 쉽다.
복수의 소켓이 한 대의 컴퓨터에 존재할 가능성이 있기 때문이다.

-----
</br>

## 12. 통로연결
애플리케이션은 Socket 라이브러리의 connect라는 프로그램 부품을 호출하여 소켓을 서버측의 소켓에 접속하도록 프로토콜 스택에 의뢰하는 동작을 수행한다.
connect를 호출할 때 디스크립터, 서버의 IP 주소, 포트 번호라는 세 가지 값을 지정한다.

IP 주소는 각 컴퓨터를 식별하기 위해 각각에 서로 다른 값을 할당한 것이다. 
그런데 IP 주소로는 소켓까지 지정할 수 없다.
즉 서버측 소켓의 디스크립터를 클라이언트에서 알 수 없으므로 클라이언트측에 알리는 중간 과정이 필요한데, 이 중간 과정이 **포트 번호**다.
서버측의 포트번호는 애플리케이션의 종류에 따라 미리 결정된 값을 사용한다.
브라우저에서 웹 서버에 액세스할 때의 포트 번호는 80번으로 결정되어 있다.

-----
</br>

## 13. 마무리
이후에는 write, read라는 프로그램 부품을 호출하여 데이터 송수신 동작을 마무리하고,
close라는 프로그램 부품을 호출하여 연결 끊기 단계로 들어간다.
이때 먼저 웹 서버측에서 close를 호출하여 연결을 끊는다.

이것이 HTTP의 본래 동작이다.
HTTP 프로토콜은 1개의 데이터를 읽을 때마다 접속, 리퀘스트 메시지 송신, 응답 메시지 수신, 연결 끊기라는 동작을 반복한다.
